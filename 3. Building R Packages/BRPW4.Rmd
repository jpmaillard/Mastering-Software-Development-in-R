---
title: "Building R Packages Week 4"
author: "Jean-Philippe Maillard"
date: "1/21/2020"
output: html_document
---

# Continuous Integration

## Overview
In modern software companies hundreds of people are simultaneously working on the source code of the same product while they develop different features for that product. At the same time those programmers are depending upon software that might be built by other teams within the company, or they may be using software built by other companies or individuals, which in turn is being actively developed and updated. The software development technique of continuous integration was developed to ensure that all of the components in this web of software are working together harmoniously.

R packages are usually not as big in terms of lines of code compared to software like Google’s search engine, however it’s plausible that your package may depend on several other packages which you want to make sure are still working the way you expected them to when you first included them in your code. When it comes to R packages continuous integration means ensuring that your package builds without any errors or warnings, and making sure that all of the tests that you’ve written for you package are passing. Building your R package will protect you against some big errors, but the best way that you can ensure continuous integration will be useful to you is if you build robust and complete tests for every function in your package.


## Web services for continous integration
We’ll discuss two services for continuous integration: the first is [Travis](https://travis-ci.org/) which will test your package on Linux, and then there’s [AppVeyor](https://www.appveyor.com/) which will test your package on Windows. Both of these services are free for R packages that are built in public GitHub repositories. These continuous integration services will run every time you push a new set of commits for your package repository. Both services integrate nicely with GitHub so you can see in GitHub’s pull request pages whether or not your package is building correctly.



## Using Travis
To start using Travis go to https://travis-ci.org and sign in with your GitHub account. Clicking on your name in the upper right hand corner of the site will bring of a list of your public GitHub repositories with a switch next to each repo. If you turn the switch on then the next time you push to that repository Travis will look for a .travis.yml file in the root of the repository, and it will run tests on your package accordingly.

Open up your R console and navigate to your R package repository. Now load the devtools package with library(devtools) and enter use_travis() into your R console. This command will set up a basic .travis.yml for your R package. You can now add, commit, and push your changes to GitHub, which will trigger the first build of your package on Travis. Go back to https://travis-ci.org to watch your package be built and tested at the same time! You may want to make some changes to your .travis.yml file, and you can see all of the options available in this [guide](https://docs.travis-ci.com/user/languages/r).

Once your package has been built for the first time you’ll be able to obtain a badge, which is just a small image generated by Travis which indicates whether you package is building properly and passing all of your tests. You should display this badge in the README.md file of your package’s GitHub repository so that you and others can monitor the build status of your package.


## Using AppVeyor
You can start using AppVeyor by going to https://www.appveyor.com/ and signing in with your GitHub account. After signing in click on “Projects” in the top navigation bar. If you have any GitHub repositories that use AppVeyor you’ll be able to see them here. To add a new project click “New Project” and find the GitHub repo that corresponds to the R package you’d like to test on Windows. Click “Add” for AppVeyor to start tracking this repo.

Open up your R console and navigate to your R package repository. Now load the devtools package with library(devtools) and enter use_appveyor() into your R console. This command will set up a default appveyor.yml for your R package. You can now add, commit, and push your changes to GitHub, which will trigger the first build of your package on AppVeyor. Go back to https://www.appveyor.com/ to see the result of the build. You may want to make some changes to your appveyor.yml file, and you can see all of the options available in the [r-appveyor guide](https://github.com/krlmlr/r-appveyor/blob/master/README.md) which is maintained by Kirill Müller. Like Travis, AppVeyor also generates badges that you should add to the README.md file of your package’s GitHub repository.


## Summary
Continuous integration is a strategy for testing new features and changes to your package as often as possible. Web services like Travis and AppVeyor make it possible to re-test your code on different platforms after every git push. Using continuous integration makes it easy for you and for others to simultaneously work on building an R package without breaking package features by mistake.



# Cross Platform Development

## Introduction
One of the great features about R is that you can run R code on multiple kinds of computers and operating systems and it will behave the same way on each one. Most of time you don’t need to worry about what platform your R code is running on. The following sections discuss strategies and functions that you should use to ensure that your R code runs uniformly on every kind of system.


## Handling paths
Paths to files and folders can have big differences between operating systems. In general you should avoid constructing a path “by hand.” For example if I wanted to access a file called data.txt that I know will be located on the user’s desktop using the string "~/Desktop/data.txt" would not work if that code was run on a Windows machine. In general you should always use functions to construct and find paths to files and folders. The correct programmatic way to construct the path above is to use the file.path() function. So to get the file above I would do the following:


```{r}
file.path("~", "Desktop", "data.txt")
#[1] "~/Desktop/data.txt"
```

Note that this book is probably being built on a Mac:
```{r}
Sys.info()['sysname']
#sysname 
#"Darwin" 
```

If the resulting line above says "Darwin" it’s refering to the core of macOS. If you don’t have a Mac try running both lines of code above to see the resulting path and the type of system that you’re running.

In general it’s not guaranteed on any system that a particular file or folder you’ve looking for will exist - however if the user of your package has installed your package you can be sure that any files within your package exist on their machine. You can find the path to files included in your package using the system.file() function. Any files or folders in the inst/ directory of your package will be copied one level up once your package is installed. If your package is called ggplyr2 and there’s file in your package under inst/data/first.txt you can get the path to that file with system.file("data", "first.txt", package = "ggplyr2"). Packaging files with your package is the best way to ensure that users have access to them when they’re using your package.

In terms of constructing paths there are a few other functions you should be aware of. Remeber that the results for many of these functions are contingent on this book being built on a Mac, so if you’re using Windows I encourage you to run these functions yourself to see their result. The path.expand() function is usually used to find the absolute path name of a user’s home directory when the tilde (~) is inlcuded in the path. The tilde is a shortcut for the path to the current user’s home directory. Let’s take a look at path.expand() in action:
```{r}
path.expand("~")
#[1] "/Users/rdpeng"
path.expand(file.path("~", "Desktop"))
#[1] "/Users/rdpeng/Desktop"
```

The normalizePath() function is built on top of path.expand(), so it includes path.expand()’s features but it also creates full paths for other shortcuts like "." which signifies the current working directory and ".." which signifies the directory above the current working directory. Let’s take a look at some examples:
```{r}
normalizePath(file.path("~", "R"))
#[1] "/Users/sean/R"
normalizePath(".")
#[1] "/Users/sean/books/msdr"
normalizePath("..")
#[1] "/Users/sean/books"
```

To extract parts of a path you can use the basename() function to get the name of the file or the deepest directory in the path and you can use dirname() to get the part of the path that does not include either the file or the deepest directory. Let’s take a look at some examples:
```{r}
data_file <- normalizePath(file.path("~", "data.txt"))
data_file
#[1] "/Users/rdpeng/data.txt"
dirname(data_file)
#[1] "/Users/rdpeng"
dirname(dirname(data_file))
#[1] "/Users"
basename(data_file)
#[1] "data.txt"
```


## Saving files and rappdirs
CRAN’s policy for R packages contains the following statement:

Packages should not write in the users’ home filespace, nor anywhere else on the file system apart from the R session’s temporary directory (or during installation in the location pointed to by TMPDIR: and such usage should be cleaned up). Installing into the system’s R installation (e.g., scripts to its bin directory) is not allowed. Limited exceptions may be allowed in interactive sessions if the package obtains confirmation from the user.

In general you should strive to get the user’s consent before you create or save files on their computer. With some functions consent is implicit, for example it’s clear somebody using write.csv() consents to producing a csv file at a specified path. When it’s not absolutely clear that the user will be creating a file or folder when they use your functions you should ask them specifically. Take a look at the code below for a skeleton of a function that asks for a user’s consent:
```{r eval = FALSE}
#' A function for doing something
#'
#' This function takes some action. It also attempts to create a file on your
#' desktop called \code{data.txt}. If \code{data.txt} cannot be created a
#' warning is raised.
#' 
#' @param force If set to \code{TRUE}, \code{data.txt} will be created on the
#' user's Desktop if their Desktop exists. If this function is used in an
#' interactive session the user will be asked whether or not \code{data.txt}
#' should be created. The default value is \code{FALSE}.
#'
#' @export
some_function <- function(force = FALSE){
  
  #
  # ... some code that does something useful ...
  #
  
  if(!dir.exists(file.path("~", "Desktop"))){
    warning("No Desktop found.")
  } else {
    if(!force && interactive()){
      result <- select.list(c("Yes", "No"), 
                  title = "May this program create data.txt on your desktop?")
      if(result == "Yes"){
        file.create(file.path("~", "Desktop", "data.txt"))
      }
    } else if(force){
      file.create(file.path("~", "Desktop", "data.txt"))
    } else {
      warning("data.txt was not created on the Desktop.")
    }
  }
}
```

The some_function() function above is a contrived example of how to ask for permission from the user to create a file on their hard drive. Notice that the description of the function clearly states that the function attempts to create the data.txt file. This function has a force argument which will create the data.txt file without asking the user first. By setting force = FALSE as the default, the user must set force = TRUE, which is one method to get consent from the user. The function above uses the interactive() function in order to determine whether the user is using this function in an R console or if this function is being run in a non-interactive session. If the user is in an interactive R session then using select.list() is a decent method to ask the user a question. You should strive to use select.list() and interactive() together in order to prevent an R session from waiting for input from a user that doesn’t exist.


## rappdirs
Even the contrived example above implicitly raises a good question: where should your package save files? The most obvious answer is to allow the user to provide an argument for the path where a file should be saved. This is a good idea as long as your package won’t need to depend on the location of that file in the future, for example if your package is creating an output data file. But what if you need persistent and consistent access to a file? You might be tempted to use path.package() in order to find the directory that your package is installed in so you can store files there. This isn’t a good idea because file access permissions often do not allow users to modify files where R packages are stored.

In order to find a location where you can read and write files that will persist on a user’s computer you should use the rappdirs package. This package contains functions that will return paths to directories where you package can store files for future use. The user_data_dir() function will provide a user-specific path for your package, while the site_data_dir() function will return a directory path that is shared by all users. Let’s take a look at rappdirs in action:
```{r}
library(rappdirs)
#Loading required package: methods
site_data_dir(appname = "ggplyr2")
#[1] "/Library/Application Support/ggplyr2"
user_data_dir(appname = "ggplyr2")
#[1] "/Users/rdpeng/Library/Application Support/ggplyr2"
```

Both of the examples above are probably the Mac-specific paths. We can get the Windows specific paths by specifying the os argument:
```{r}
user_data_dir(appname = "ggplyr2", os = "win")
#[1] "C:/Users/<username>/Local/ggplyr2/ggplyr2"
```

If you don’t supply the os argument then the function will determine the operating system automatically. One feature about user_data_dir() you should note is the roaming = TRUE argument. Many Windows networks are configured so that any authorized user can log in to any computer on the network and have access to their desktop, settings, and files. Setting roaming = TRUE returns a special path so that R will have access to your packages files everywhere, but this requires the directory to be synced often. Make sure to only use roaming = TRUE if the files your package will storing with rappdirs are going to be small. For more information about rappdirs see https://github.com/hadley/rappdirs.


## Options and starting r
Several R Packages allow users to set global options that effect the behavior of the package using the options() function. The options() function returns a list, and named values in this list can be set using the following syntax: options(key = value). It’s a common feature for packages to allow a user to set options which may specify package defaults, or change the behavior of the package in some way. You should thoroughly document how your package is effected by which options are set.

When an R session begins a series of files are searched for and run if found as detailed in help("Startup"). One of those files is .Rprofile. The .Rprofile file is just a regular R file which is usually located in a user’s home directory (which you can find with normalizePath("~")). A user’s .Rprofile is run every time they start an R session, so it’s a good file for setting options that a user wants to be set when using R. If you want a user to be able to set an option that is related to your package that is unlikely to change (like a username or a key), then you should consider instructing them to create or make changes to their .Rprofile.


## Package installation
Your package documentation should prominently feature installation instructions. Many R packages that are distributed through GitHub recommend installing the devtools package, and then using devtools::install_github() to install the package. The devtools package is wonderful for developing R packages, but it has many dependencies whhich can make it difficult for users to install. I recommend instructing folks to use the ghit package by Thomas Leeper and the ghit::install_github() function as a reliable alternative to devtools.

In cases where users might have a weak internet connection it’s often easier for a user to download the source of your package as a zip file and then to install it using install.packages(). Instead of asking users to discern the path of zip file they’ve downloaded you should ask them to enter install.packages(file.choose(), repos = NULL, type = "source") into the R console and then they can interactively select the file they just downloaded. If a user is denied permission to modify their local package directory, they still may be able to use a package if they specify a directory they have access to with the lib argument for install.packages().


## Environmental attributes
onally you may need to know specific information about the hardware and software limitations of the computer that is running your R code. The environmental variables .Platform and .Machine are lists which contain named elements that can tell your program about the underlying machine. For example .Platform$OS.type is a good method for checking whether your program is in a Windows environment since the only values it can return are "windows" and "unix":
```{r}
.Platform$OS.type
#[1] "unix"
```

For more information about information contained in .Platform see the help file: help(".Platform").

The .Machine variable contains information specific to the computer architecture that your program is being run on. For example .Machine$double.xmax and .Machine$double.xmin are respectively the largest and smallest positive numbers that can be represented in R on your platform:
```{r}
.Machine$double.xmax
#[1] 1.797693e+308
.Machine$double.xmax + 100 == .Machine$double.xmax
#[1] TRUE
.Machine$double.xmin
#[1] 2.225074e-308
```

You might also find .Machine$double.eps useful, which is the smallest number on a machine such that 1 + .Machine$double.eps != 1 evaluates to TRUE:
```{r}
1 + .Machine$double.eps != 1
#[1] TRUE
1 + .Machine$double.xmin != 1
#[1] FALSE
```


## Summary
File and folder paths differ across platforms so R provides several functions to ensure that your program can construct paths correctly. The rappdirs package helps further by identifying locations where you can safely store files that your package can access. However before creating files anywhere on a user’s disk you should always ask the user’s permission. You should provide clear and easy instructions so people can easily install your package. The .Platform and .Machine variables can inform your program about hardware and software details.





